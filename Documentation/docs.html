<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
	<title>SCH - Docs</title>
	<link rel="icon" href="logo.png">
</head>
<body>
	<div id="nav-placeholder">
			<div class="nav_bar">
				<a href="home.html">Home</a>
				<a href="docs.html">Docs</a>
				<a href="downloads.html">Downloads</a>
			</div>
		</div>
	<!--
		<script>
			function loadFile(filePath) {
				var result = null;
				var xmlhttp = new XMLHttpRequest();
				xmlhttp.open("GET", filePath, false);
				xmlhttp.send();
				if (xmlhttp.status==200) {
					result = xmlhttp.responseText;
				}
				return result;
			}
			document.getElementById('nav-placeholder').innerHTML = loadFile("navbar.html");
		</script>
	!-->
	<div class="side_bar" id="side_bar">
		<a href="#Comments">Comments</a>
		<a href="#Packages">Packages</a>
		<a href="#Functions">Functions</a>
		<a href="#Basic_types">Basic types</a>
		<a href="#Operators">Operators</a>
		<a href="#Entry_point">Entry point</a>
		<a href="#Variables">Variables</a>
		<a href="#Intrinsic_functions">Intrinsic functions</a>
		<a href="#Printing">Printing</a>
		<a href="#Loops,_branches_and_scopes">Loops, branches and scopes</a>
		<a href="#Arrays">Arrays</a>
		<a href="#Lambda_expressions">Lambda expressions</a>
		<a href="#Classes">Classes</a>
		<a href="#Smart_casting">Smart casting</a>
		<a href="#Null">Null</a>
		<a href="#Tuples">Tuples</a>
		<a href="#Unwrapping">Unwrapping</a>
	</div>
	
	<div class="main" id="main">
	<h2 id="Comments">Comments</h2>
<div class="c"><span class="red">func</span> <span class="green">main</span>(): <span class="blue">i32</span> {  <span class="gray">// this is a line comment</span>
	<span class="red">return</span> <span class="purple">10</span>
<span class="gray">/*</span>
<span class="gray">	This is a</span>
<span class="gray">	block comment</span>
<span class="gray">*/</span>
}
</div>	<h2 id="Packages">Packages</h2>
Every file is contained in a package. The package has to be named in the first line of the file. If it isn't, the default package is called <span class="inline-code">main</span>.<br>
<div class="c"><span class="red">package</span> test
</div>Packages can be imported after the package declaration.<br>
<div class="c"><span class="red">package</span> test

<span class="red">import</span> apple
<span class="red">import</span> tree
<span class="red">import</span> water
</div>You can use names that are declared in other packages.<br>
<div class="c"><span class="red">package</span> main

<span class="red">import</span> apple

<span class="red">func</span> <span class="green">main</span>() {
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, abc)  <span class="gray">// 'abc' is imported from 'apple' and can be used like a normal variable</span>
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, tree::def)  <span class="gray">// 'tree' isn't imported, so the package has to be explicit</span>
}
</div><div class="c"><span class="red">package</span> apple

<span class="blue">var</span> abc = <span class="purple">10</span>
</div><div class="c"><span class="red">package</span> tree

<span class="blue">var</span> def = <span class="purple">50</span>
</div>	<h2 id="Functions">Functions</h2>
	<h3>Declaration</h3>
A function <span class="inline-code">func1</span> with two arguments <span class="inline-code">a</span> and <span class="inline-code">b</span> of type <span class="inline-code"><span class="blue">i32</span></span>, returning <span class="inline-code"><span class="blue">i32</span></span>.<br>
<div class="c"><span class="red">func</span> <span class="green">func1</span>(a: <span class="blue">i32</span>, b: <span class="blue">i32</span>): <span class="blue">i32</span> {
	<span class="gray">// do stuff</span>
}
</div>	<h3>Function calls</h3>
<div class="c"><span class="red">func</span> <span class="green">func1</span>() {
	<span class="gray">// do stuff</span>
}
<span class="red">func</span> <span class="green">func2</span>() {
	<span class="green">func1</span>()
}
</div>	<h3>Return</h3>
A function can return any object of a specified <span class="inline-code">return type</span>.<br>
<div class="c"><span class="red">func</span> <span class="green">func1</span>(): <span class="blue">i32</span> {  <span class="gray">// 'i32' is the return type</span>
	<span class="gray">// do stuff</span>

	<span class="red">return</span> <span class="purple">1989</span>
}
<span class="red">func</span> <span class="green">func2</span>() {
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, <span class="green">func1</span>())  <span class="gray">// 1989</span>

	<span class="red">return</span> <span class="gray">// functions that return 'void' don't require a return statement</span>
}
</div>	<h3>Arguments</h3>
A function can accept arguments.<br>
<div class="c"><span class="red">func</span> <span class="green">func1</span>(a: <span class="blue">i32</span>, b: <span class="blue">i32</span>) {
	<span class="green">println!</span>(<span class="yellow">"{}, {}"</span>, a, b)
}
<span class="red">func</span> <span class="green">func2</span>() {
	<span class="green">func1</span>(<span class="purple">20</span>, <span class="purple">21</span>)
}
</div>	<h2 id="Basic_types">Basic types</h2>
	<h3>Void</h3>
The <span class="inline-code"><span class="blue">void</span></span> type indicates that a function doesn't return anything.<br>
<div class="c"><span class="red">func</span> <span class="green">func1</span>(): <span class="blue">void</span> {

}
</div>If a function returns <span class="inline-code"><span class="blue">void</span></span>, the return type doesn't have to be explicitly named.<br>
<div class="c"><span class="red">func</span> <span class="green">func2</span>() {  <span class="gray">// this is the same</span>

}
</div><span class="inline-code"><span class="blue">void</span></span> can only be used as a return type.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">void</span>  <span class="gray">// this doesn't compile</span>
</div>	<h3>Booleans</h3>
Booleans are either <span class="inline-code"><span class="purple">true</span></span> or <span class="inline-code"><span class="purple">false</span></span>.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">bool</span> = <span class="purple">true</span>
<span class="blue">var</span> b: <span class="blue">bool</span> = <span class="purple">false</span>
</div>	<h3>Integers</h3>
There are eight different integer types.<br>
Their name consist of either an <span class="inline-code">i</span> or a <span class="inline-code">u</span>, depending on whether the integer is <span class="inline-code">signed</span> or <span class="inline-code">unsigned</span>.<br>
The letter is followed by a number, which represents the integer size.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">i32</span> = <span class="purple">-200_000_000</span>  <span class="gray">// underscores are optional</span>
<span class="blue">var</span> b: <span class="blue">u16</span> = <span class="purple">65000</span>
<span class="blue">var</span> c: <span class="blue">i8</span>  = <span class="purple">-15</span>
</div>The integer size must be 8, 16, 32 or 64.<br>
	<h3>Strings</h3>
Strings are just <span class="inline-code"><span class="blue">i8</span>[]</span>.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">i8</span>[] = <span class="yellow">"Hello, world!"</span>
</div>	<h2 id="Operators">Operators</h2>
	<table>
		<tr>
			<td>Or 				</td>
			<td><span class="inline-code"><span class="purple">true</span> || <span class="purple">false</span>  =>  <span class="purple">true</span></span></td>
			<td>Second condition is not evaluated if the first one is <span class="inline-code"><span class="purple">true</span></span>.</td>
		</tr>
		<tr>
			<td>-</td>
		</tr>
		<tr>
			<td>And				</td>
			<td><span class="inline-code"><span class="purple">true</span> && <span class="purple">true</span>  =>  <span class="purple">true</span></span></td>
			<td>Second condition is not evaluated if the first one is <span class="inline-code"><span class="purple">false</span></span>.</td>
		</tr>
		<tr>
			<td>-</td>
		</tr>
		<tr>
			<td>Equals			</td>
			<td><span class="inline-code"><span class="purple">3</span> == <span class="purple">3</span>  =>  <span class="purple">true</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Unequal			</td>
			<td><span class="inline-code"><span class="purple">3</span> != <span class="purple">2</span>  =>  <span class="purple">true</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>-</td>
		</tr>
		<tr>
			<td>Less than		</td>
			<td><span class="inline-code"><span class="purple">3</span> < <span class="purple">5</span>  =>  <span class="purple">true</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Less or equal	</td>
			<td><span class="inline-code"><span class="purple">3</span> <= <span class="purple">5</span>  =>  <span class="purple">true</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Greater or equal</td>
			<td><span class="inline-code"><span class="purple">3</span> >= <span class="purple">5</span>  =>  <span class="purple">true</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Greater than	</td>
			<td><span class="inline-code"><span class="purple">5</span> > <span class="purple">3</span>  => <span class="purple">true</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>-</td>
		</tr>
		<tr>
			<td>Plus			</td>
			<td><span class="inline-code"><span class="purple">3</span> + <span class="purple">5</span>  =>  <span class="purple">8</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Minus			</td>
			<td><span class="inline-code"><span class="purple">5</span> - <span class="purple">3</span>  =>  <span class="purple">2</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>-</td>
		</tr>
		<tr>
			<td>Multiply		</td>
			<td><span class="inline-code"><span class="purple">3</span> * <span class="purple">5</span>  =>  <span class="purple">15</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Divide			</td>
			<td><span class="inline-code"><span class="purple">6</span> / <span class="purple">3</span>  =>  <span class="purple">2</span></span></td>
			<td></td>
		</tr>
		<tr>
			<td>Modulo			</td>
			<td><span class="inline-code"><span class="purple">3</span> % <span class="purple">5</span>  =>  <span class="purple">2</span></span></td>
			<td></td>
		</tr>
	</table>
Integer operators can use different types, but only if they are both signed/unsigned. The smaller sized integer is converted to the bigger size.<br>
	<h2 id="Entry_point">Entry point</h2>
The entry point is the <span class="inline-code">main</span> function.<br>
<div class="c"><span class="red">func</span> <span class="green">main</span>(): <span class="blue">i32</span> {
	<span class="gray">// do stuff</span>
}
</div>	<h2 id="Variables">Variables</h2>
A variable is a mutable storage unit with a specific name and type.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">i32</span>
<span class="blue">var</span> b: <span class="blue">i32</span> = <span class="purple">15</span>
<span class="blue">var</span> c = <span class="purple">30</span>
</div>You can also declare multiple variables in one line.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">i32</span>, b: <span class="blue">i8</span>[], c: <span class="blue">i32</span>
a, b, c = <span class="purple">13</span>, <span class="yellow">"Hello"</span>, <span class="purple">1989</span>
<span class="blue">var</span> d, e: <span class="blue">i8</span>[], f: <span class="blue">i32</span> = <span class="purple">13</span>, <span class="yellow">"Hello"</span>, <span class="purple">1989</span>  <span class="gray">// naming types is still optional</span>
</div>	<h3>Global variables</h3>
Variable declarations can also be top level elements. However, if you are using variables that haven't been declared yet as values of global variables, you have to explicitly write the name.<br>
<div class="c"><span class="blue">var</span> a = <span class="purple">10</span>
<span class="blue">var</span> b = a
<span class="blue">var</span> c: <span class="blue">i8</span>[] = d  <span class="gray">// type has to explicit as 'd' hasn't been declared yet</span>
<span class="blue">var</span> d = <span class="yellow">"Hello"</span>
</div>	<h2 id="Intrinsic_functions">Intrinsic functions</h2>
An intrinsic function can be used like a normal function, but they cannot be declared by the user. Instead, they are declared in the standard library.<br>
Intrinsic functions are responsible for performing tasks, that aren't possible with raw code.<br>
You call them like regular functions, but with a <span class="inline-code">!</span> after the name.<br>
<div class="c"><span class="green">func1!</span>(<span class="purple">10</span>, <span class="purple">15</span>)
</div>	<h2 id="Printing">Printing</h2>
Printing is done via a use of the <span class="inline-code">println</span> intrinsic.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"Hello, world!"</span>)  <span class="gray">// prints `Hello, world!` with a new line</span>
</div>The first argument is a string literal, the <span class="inline-code">formatter string</span>. It can be a simple string, but it can also include <span class="inline-code">{}</span> to interpolate other objects.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"It's {}:{} a.m."</span>, <span class="purple">7</span>, <span class="purple">13</span>)  <span class="gray">// It's 7:13 a.m.</span>
</div>You can also put formatting specifiers inside the curly brackets.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"My favorite letter is `{c}`"</span>, <span class="purple">65</span>)  <span class="gray">// My favorite letter is `A`</span>

<span class="green">println!</span>(<span class="yellow">"My favorite artist is {s}"</span>, <span class="yellow">"Olivia Rodrigo"</span>)  <span class="gray">// My favorite artist is Olivia Rodrigo</span>

<span class="green">println!</span>(<span class="yellow">"My favorite hexadecimal number is {x}"</span>, <span class="purple">65536</span>)  <span class="gray">// My favorite hexadecimal number is 10000</span>
</div>	<h2 id="Loops,_branches_and_scopes">Loops, branches and scopes</h2>
	<h3>Scopes</h3>
A scope is a block of code. Variables declared inside the block aren't accessible outside the scope.<br>
<div class="c"><span class="blue">var</span> a = <span class="purple">10</span>
{
	<span class="blue">var</span> b = <span class="purple">50</span>
	<span class="green">println!</span>(<span class="yellow">"{}, {}"</span>, a, b)  <span class="gray">// 10, 50</span>
	a = <span class="purple">20</span>
}
<span class="green">println!</span>(<span class="yellow">"{}"</span>, a)  <span class="gray">// 20</span>
<span class="green">println!</span>(<span class="yellow">"{}"</span>, b)  <span class="gray">// doesn't work</span>
</div>Scopes can be expressions. In that case, the last element in the scope will be passed from the scope.<br>
<div class="c"><span class="blue">var</span> a = {
	<span class="green">println!</span>(<span class="yellow">"Heyy"</span>)
	<span class="purple">15</span>
}
<span class="green">println!</span>(<span class="yellow">"{}"</span>, a)  <span class="gray">// 15</span>
</div>	<h3>While</h3>
A <span class="inline-code"><span class="red">while</span></span> loop executes an element as long as a condition is <span class="inline-code"><span class="purple">true</span></span>.<br>
<div class="c"><span class="blue">var</span> a = <span class="purple">0</span>
<span class="red">while</span>(a < <span class="purple">10</span>) a += <span class="purple">1</span>
<span class="green">println!</span>(<span class="yellow">"{}"</span>, a)  <span class="gray">// 10</span>

<span class="red">while</span>(a > <span class="purple">0</span>) {
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, a)
	a -= <span class="purple">1</span>
}
</div>	<h3>For</h3>
A <span class="inline-code"><span class="red">for</span></span> loop is similar to a <span class="inline-code"><span class="red">while</span></span> loop, with two small changes.<br>
<div class="c"><span class="red">for</span>(<span class="blue">var</span> i = <span class="purple">0</span>; i < <span class="purple">10</span>; i += <span class="purple">1</span>)
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, i)  <span class="gray">// prints all numbers from 0 to 9</span>
</div>The first part in the parentheses can be any element, but it's usually a variable declaration.<br>
The advantage of declaring the variable there instead of before the loop, is that it's in a separate scope that way, meaning that you cannot access the variable outside the loop.<br>
The second part is the condition, similar to the <span class="inline-code"><span class="red">while</span></span> loop.<br>
The third part is an element that is executed after every rollback to the start of the loop, even when it's caused by a <span class="inline-code"><span class="red">continue</span></span>.<br>
The first and third part can also be omitted.<br>
<div class="c"><span class="red">for</span>(; <span class="purple">true</span>;) {
	<span class="gray">// do stuff</span>
}
</div>Of course, leaving out both wouldn't make much sense, and it then can be replaced by a <span class="inline-code"><span class="red">while</span></span> statement.<br>
	<h3>Break and continue</h3>
A <span class="inline-code"><span class="red">break</span></span> statement exits the most recent loop.<br>
<div class="c"><span class="red">for</span>(<span class="blue">var</span> i = <span class="purple">0</span>; <span class="purple">true</span>; i += <span class="purple">1</span>) {
	<span class="red">if</span>(i > <span class="purple">8</span>)
		<span class="red">break</span>
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, i)  <span class="gray">// 0 to 8 (including).</span>
}
</div>A <span class="inline-code"><span class="red">continue</span></span> statement jumps back to the start. In a for loop, the third element in the brackets is still executed.<br>
<div class="c"><span class="red">for</span>(<span class="blue">var</span> i = <span class="purple">0</span>; i < <span class="purple">10</span>; i += <span class="purple">1</span>) {
	<span class="red">if</span>(i % <span class="purple">2</span> == <span class="purple">0</span>)
		<span class="red">continue</span>
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, i)  <span class="gray">// all odd numbers from 1 to 9 (including)</span>
}
</div>	<h3>If</h3>
An <span class="inline-code"><span class="red">if</span></span> branch is used to execute code only if a condition is <span class="inline-code"><span class="purple">true</span></span>.<br>
<div class="c"><span class="red">if</span>(a < <span class="purple">5</span>) {
	<span class="green">println!</span>(<span class="yellow">"Hello, world!"</span>)
}
</div>You can also add <span class="inline-code"><span class="red">else</span> <span class="red">if</span></span> and <span class="inline-code"><span class="red">else</span></span> branches.<br>
<div class="c"><span class="red">if</span>(a < <span class="purple">5</span>) {
	<span class="green">println!</span>(<span class="yellow">"Hello, world!"</span>)
}
<span class="red">else</span> <span class="red">if</span>(a < <span class="purple">10</span>) {
	<span class="green">println!</span>(<span class="yellow">"World!"</span>)
}
<span class="red">else</span> <span class="green">println!</span>(<span class="yellow">"Bye, world!"</span>)
</div><span class="inline-code"><span class="red">if</span></span> branches can be used as expressions, as long as they have an <span class="inline-code"><span class="red">else</span></span> branch.<br>
<div class="c"><span class="blue">var</span> b: <span class="blue">i32</span> = <span class="red">if</span>(a < <span class="purple">5</span>) <span class="purple">20</span> <span class="red">else</span> <span class="red">if</span>(a < <span class="purple">10</span>) <span class="purple">50</span> <span class="red">else</span> <span class="purple">-10</span>
</div>	<h2 id="Arrays">Arrays</h2>
An array is a collection of objects of the same type.<br>
Array types are written as the base type followed by <span class="inline-code">[]</span>.<br>
<div class="c"><span class="blue">var</span> a: <span class="blue">i32</span>[]
</div>You can create them by listing every item.<br>
<div class="c"><span class="blue">var</span> a = <span class="red">new</span> <span class="blue">i32</span>[<span class="purple">1</span>, <span class="purple">2</span>, <span class="purple">3</span>, <span class="purple">4</span>, <span class="purple">5</span>]

<span class="blue">var</span> b = <span class="red">new</span>[<span class="purple">1</span>, <span class="purple">2</span>, <span class="purple">3</span>, <span class="purple">4</span>, <span class="purple">5</span>]  <span class="gray">// the base type can usually be inferred implicitly</span>
</div>And you can create them with a specific size and a function that returns the objects for each index.<br>
<div class="c"><span class="blue">var</span> a = <span class="red">new</span> <span class="blue">i32</span>{<span class="purple">10</span>, <span class="blue">i32</span>{ i: <span class="blue">i32</span> => i }}
</div>In this example, <span class="inline-code">a</span> is filled with all numbers from 0 to 9 (including)<br>
	<h3>Length</h3>
The length of an array can be determined using the <span class="inline-code">len</span> intrinsic.<br>
<div class="c"><span class="blue">var</span> a = <span class="red">new</span>[<span class="purple">1</span>, <span class="purple">2</span>, <span class="purple">3</span>, <span class="purple">4</span>, <span class="purple">5</span>]
<span class="green">println!</span>(<span class="yellow">"The array contains {} elements"</span>, <span class="green">len!</span>(a))  <span class="gray">// The array contains 5 elements</span>
</div>	<h3>Get</h3>
You can get a specific element of an array.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"The first element is {}"</span>, <span class="green">a</span>[<span class="purple">0</span>])  <span class="gray">// 1</span>
</div>If the index is negative, the length of the array is added to it.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"The last element is {}"</span>, <span class="green">a</span>[<span class="purple">-1</span>])  <span class="gray">// 5</span>
<span class="green">println!</span>(<span class="yellow">"The element before that is {}"</span>, <span class="green">a</span>[<span class="purple">-2</span>])  <span class="gray">// 4</span>
</div>If the index is not in the bounds of the array (e.g. greater or equal to the length or less than the negative length), an error is thrown.<br>
	<h3>Set</h3>
Setting a specific element of an array to a different value works similar.<br>
<div class="c"><span class="green">a</span>[<span class="purple">0</span>] = <span class="purple">15</span>
<span class="green">a</span>[<span class="purple">-1</span>] = <span class="purple">20</span>
<span class="green">a</span>[<span class="purple">-6</span>] = <span class="purple">100</span>  <span class="gray">// error</span>
</div>	<h2 id="Lambda_expressions">Lambda expressions</h2>
<div class="c"><span class="blue">var</span> a: <span class="blue">i32</span>(<span class="blue">i8</span>[]) = { str => <span class="purple">15</span> }
<span class="blue">var</span> b = <span class="blue">i32</span>{ str: <span class="blue">i8</span>[] => <span class="purple">15</span> }
<span class="blue">var</span> c = <span class="blue">i32</span>{ =>
	<span class="green">println!</span>(<span class="yellow">"Hello, world!"</span>)
	<span class="red">return</span> <span class="purple">15</span>
}
<span class="blue">var</span> d: <span class="blue">void</span>() = <span class="blue">void</span>{ => <span class="green">println!</span>(<span class="yellow">"Hey"</span>) }  <span class="gray">// if a one-line lambda expression returns void, it has to be explicit</span>
<span class="blue">var</span> e: <span class="blue">void</span>() = { =>
	<span class="green">println!</span>(<span class="yellow">"Hey"</span>)
}  <span class="gray">// multiline expression, therefore the return type doesn't have to be explicit</span>
</div>	<p class="attention"><b>! Capturing variables is not yet possible and crashes the compiler if you try anyway !</b></p>
	<h2 id="Classes">Classes</h2>
Classes are declared as top level elements.<br>
<div class="c"><span class="red">class</span> <span class="green">Class1</span> {
	<span class="gray">// stuff</span>
}
</div>They need one constructor. That is just a function that is called when an instance of the class is created. However, they cannot return.<br>
<div class="c"><span class="red">class</span> <span class="green">Class1</span> {
	<span class="red">constructor</span>(a: <span class="blue">i32</span>) {
		<span class="gray">// do stuff</span>
	}
}
</div>You can create new instances using the <span class="inline-code"><span class="red">new</span></span> keyword.<br>
<div class="c"><span class="blue">var</span> a: Class1 = <span class="red">new</span> <span class="green">Class1</span>(<span class="purple">15</span>)  <span class="gray">// argument is passed on to constructor</span>
</div>	<h3>Properties</h3>
Classes can contain variables, so called <span class="inline-code">properties</span>.<br>
They cannot be directly initialized. Instead, they have to be initialized in the constructor.<br>
<div class="c"><span class="red">class</span> <span class="green">Class1</span> {
	<span class="blue">var</span> name: <span class="blue">i8</span>[]
	<span class="blue">var</span> age: <span class="blue">i32</span>

	<span class="red">constructor</span>(age: <span class="blue">i32</span>) {
		name = <span class="yellow">"Abigail"</span>
		<span class="purple">this</span>.age = age  <span class="gray">// `this` is a reference to the new instance</span>
	}
}
</div>You can access them using a <span class="inline-code">.</span>.<br>
<div class="c"><span class="blue">var</span> a = <span class="red">new</span> <span class="green">Class1</span>(<span class="purple">15</span>)
<span class="green">println!</span>(<span class="yellow">"{s}, {}"</span>, a.name, a.age)  <span class="gray">// Abigail, 15</span>
</div>You can also change them.<br>
<div class="c">a.age = <span class="purple">16</span>
</div>	<h3>Functions</h3>
A class can also contain functions.<br>
<div class="c"><span class="red">class</span> <span class="green">Class1</span> {
	<span class="blue">var</span> name: <span class="blue">i8</span>[]
	<span class="blue">var</span> age: <span class="blue">i32</span>

	<span class="red">constructor</span>(age: <span class="blue">i32</span>) {
    	name = <span class="yellow">"Abigail"</span>
    	<span class="purple">this</span>.age = age
    }

    <span class="red">func</span> <span class="green">print</span>() {
    	<span class="green">println!</span>(<span class="yellow">"{s}, {}"</span>, name, age)  <span class="gray">// Abigail, 15</span>
    }
}
</div>They can be accessed like properties, but they cannot be changed.<br>
<div class="c">a.<span class="green">print</span>()
</div>	<h3>Inheritance</h3>
A class can be a subclass of another class.<br>
<div class="c"><span class="red">class</span> <span class="green">Human</span> {
	<span class="blue">var</span> name: <span class="blue">i8</span>[]
	<span class="red">constructor</span>(name: <span class="blue">i8</span>[]) {
		<span class="purple">this</span>.name = name
	}

	<span class="red">func</span> <span class="green">print</span>() {
		<span class="green">println!</span>(<span class="yellow">"My name is {s}"</span>, name)
	}
}
<span class="red">class</span> Student : <span class="green">Human</span> {  <span class="gray">// Student is a subclass of Human</span>
	<span class="blue">var</span> grade: <span class="blue">i32</span>
	<span class="red">constructor</span>(name: <span class="blue">i8</span>[], grade: <span class="blue">i32</span>) {
		<span class="purple">this</span>.name = name  <span class="gray">// `name` is passed on from Human and thus has to be initialized</span>
		<span class="purple">this</span>.grade = grade
	}
}
</div><span class="inline-code">Student</span> can be treated now as <span class="inline-code">Human</span>.<br>
<div class="c"><span class="red">func</span> <span class="green">nameLength</span>(parent: Parent): <span class="blue">i32</span> {
	<span class="red">return</span> <span class="green">len!</span>(parent.name)
}
<span class="red">func</span> <span class="green">main</span>(): <span class="blue">i32</span> {
	<span class="blue">var</span> student = <span class="red">new</span> <span class="green">Student</span>(<span class="yellow">"Tim"</span>, <span class="purple">10</span>)
	student.<span class="green">print</span>()  <span class="gray">// function is taken on from Human</span>

	<span class="green">nameLength</span>(student)  <span class="gray">// `Student` is of type `Human`</span>

	<span class="red">return</span> <span class="purple">0</span>
}
</div>	<h3>Virtual and override</h3>
A function in a class can be <span class="inline-code"><span class="red">virtual</span></span>.<br>
<div class="c"><span class="red">class</span> <span class="green">Human</span> {
	<span class="blue">var</span> name: <span class="blue">i8</span>[]
	<span class="red">constructor</span>(name: <span class="blue">i8</span>[]) {
		<span class="purple">this</span>.name = name
	}

	<span class="red">virtual</span> <span class="red">func</span> <span class="green">print</span>() {
		<span class="green">println!</span>(<span class="yellow">"My name is {s}"</span>, name)
	}
}
</div>Virtual functions can be overridden by subclasses and get a new implementation.<br>
<div class="c"><span class="red">class</span> Student : <span class="green">Human</span> {
	<span class="blue">var</span> grade: <span class="blue">i32</span>
	<span class="red">constructor</span>(name: <span class="blue">i8</span>[], grade: <span class="blue">i32</span>) {
		<span class="purple">this</span>.name = name
		<span class="purple">this</span>.grade = grade
	}
	
	<span class="red">override</span> <span class="red">func</span> <span class="green">print</span>() {  <span class="gray">// function signature has to stay the same</span>
		<span class="green">println!</span>(<span class="yellow">"My name is {s} and I`m in grade {}"</span>, name, grade)
	}
}
</div>If you call <span class="inline-code">print</span> now, the program will automatically figure out which function it has to call.<br>
<div class="c"><span class="red">new</span> <span class="green">Human</span>().<span class="green">print</span>()  <span class="gray">// calls Human.print</span>
<span class="red">new</span> <span class="green">Student</span>().<span class="green">print</span>()  <span class="gray">// calls Student.print</span>
</div>This even works when you don't know the type of the object.<br>
<div class="c"><span class="red">func</span> <span class="green">test</span>(p: Parent) {
	p.<span class="green">print</span>()  <span class="gray">// figures out which function to call</span>
}
</div>	<h3>Type checking</h3>
You can check whether an object is an instance of a certain class using the <span class="inline-code">~</span> operator.<br>
<div class="c"><span class="red">if</span>(a ~ Student)
	<span class="green">println!</span>(<span class="yellow">"It is a student!"</span>)  <span class="gray">// will only print if a is a student</span>
</div>Let's say <span class="inline-code">a</span> is of type <span class="inline-code">Student</span>.<br>
<div class="c"><span class="red">if</span>(a ~ Human)
	<span class="green">println!</span>(<span class="yellow">"It is a human!"</span>)
</div>This code will still print, as <span class="inline-code">Student</span> is a subclass of <span class="inline-code">Human</span>.<br>
Type checking only works on classes.<br>
	<h2 id="Smart_casting">Smart casting</h2>
Look at the following example.<br>
<div class="c"><span class="blue">var</span> a: Human = <span class="red">new</span> <span class="green">Student</span>(<span class="yellow">"Tim"</span>, <span class="purple">10</span>)
<span class="green">println!</span>(<span class="yellow">"{}"</span>, a.grade)
</div>Although <span class="inline-code">a</span> is of type <span class="inline-code">Human</span>, you can use it as a <span class="inline-code">Student</span>, because the compiler knows that it has to be an instance of that type.<br>
This also works after a type check.<br>
<div class="c"><span class="red">if</span>(a ~ Student)
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, a.grade)
</div>However, as soon as you change the value of <span class="inline-code">a</span>, the compiler will forget the smart cast type, as the type may have changed.<br>
<div class="c"><span class="red">if</span>(a ~ Student) {
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, a.grade)
	a = <span class="red">new</span> <span class="green">Human</span>(<span class="yellow">"Taylor Swift"</span>)
	<span class="green">println!</span>(<span class="yellow">"{}"</span>, a.grade)  <span class="gray">// doesn't work anymore</span>
}
</div>Note that smart casting only works on variables, not on properties or array elements.<br>
	<h2 id="Null">Null</h2>
Heap allocated objects (classes and arrays) can be nullable. That is indicated by adding a <span class="inline-code">?</span> after the type name.<br>
<div class="c"><span class="blue">var</span> a: Human?
</div>Nullable objects can be instances of the base type...<br>
<div class="c">a = <span class="red">new</span> <span class="green">Human</span>(<span class="yellow">"Taylor Swift"</span>)
</div>...but they can also be <span class="inline-code"><span class="purple">null</span></span>.<br>
<div class="c">a = <span class="purple">null</span>
</div>You cannot do anything with nullable objects, as there's always the potential of them being <span class="inline-code"><span class="purple">null</span></span>, which would result in undefined behavior.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"{s}"</span>, a.name)  <span class="gray">// doesn't work</span>
</div>However, you can <span class="inline-code">null assert</span> them.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"{}"</span>, a!!.name)  <span class="gray">// does work</span>
</div>If <span class="inline-code">a</span> was <span class="inline-code"><span class="purple">null</span></span> in this case, a runtime error would occur.<br>
Smart casting also works with null asserts.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"{}"</span>, a!!.name)
<span class="green">println!</span>(<span class="yellow">"{}"</span>, a.name)  <span class="gray">// compiler knows that 'a' cannot be null here</span>
</div>	<h2 id="Tuples">Tuples</h2>
Tuples are immutable collections of elements.<br>
<div class="c"><span class="blue">var</span> a: (<span class="blue">i32</span>, <span class="blue">i8</span>[])
a = (<span class="purple">100</span>, <span class="yellow">"abc"</span>)
</div>The names of the elements are their indexes by default, but you can change them.<br>
<div class="c">a = (p3: <span class="purple">100</span>, p4: <span class="purple">500</span>)
<span class="blue">var</span> b: (p1: <span class="blue">i32</span>, <span class="blue">i8</span>[])
b = (<span class="purple">50</span>, <span class="yellow">"def"</span>)
</div>You can access its elements.<br>
<div class="c"><span class="green">println!</span>(<span class="yellow">"{}"</span>, a.0)  <span class="gray">// 100</span>
<span class="green">println!</span>(<span class="yellow">"{s}"</span>, a.1)  <span class="gray">// abc</span>
<span class="green">println!</span>(<span class="yellow">"{}, {}"</span>, b.p1, b.1)  <span class="gray">// 50, def</span>
</div>However, you cannot reassign them.<br>
<div class="c">a.0 = <span class="purple">50</span>  <span class="gray">// doesn't work</span>
</div>	<h2 id="Unwrapping">Unwrapping</h2>
Unwrapping currently is only supported on tuples. It is used to use multiple elements inside one object as separate arguments.<br>
<div class="c"><span class="blue">var</span> tuple = (<span class="purple">1</span>, <span class="purple">2</span>, <span class="purple">3</span>)
<span class="green">println!</span>(<span class="yellow">"{} {} {}"</span>, tuple...)  <span class="gray">// 1 2 3</span>
</div>An unwrapped value can be enclosed by other arguments.<br>
<div class="c"><span class="green">test</span>(<span class="purple">1</span>, <span class="purple">2</span>, tuple..., <span class="purple">78</span>)
</div>Unwrapping also works in variable initialization.<br>
<div class="c"><span class="blue">var</span> a, b, c, d = tuple..., <span class="purple">25</span>
a, b, c = tuple...
</div>If you don't want a specific element of a tuple in a variable declaration, you can name the variable <span class="inline-code">_</span>.<br>
<div class="c"><span class="blue">var</span> a, _, _, b = tuple..., <span class="purple">100</span>
</div>	</div>
	<script>
		if (screen.width < 1500) {
            document.getElementById('side_bar').hidden = 'hidden';
        	document.getElementById('main').style.paddingLeft = 0;
    	}
    </script>
</body>
</html>